Static ↔ Dynamic
Static ↔ Instance


#
Constructor
Static
Instance
#
Constructor
Static properties
Static methods
Instance properties
Instance methods


#
A
ㄴConstructor         ▶A()        
ㄴStatic              ▶A.
ㄴInstance            ▶a.
#
A
ㄴConstructor        ▶A()        
ㄴStatic properties  ▶A.a
ㄴStatic methods     ▶A.a()
ㄴInstance properties▶a.a
ㄴInstance methods   ▶a.a()
#
A
ㄴA()        
ㄴA.a
ㄴA.a()
ㄴa.a
ㄴa.a()


# Constructor
A()
new A()
a=new A()
# property
field
fields
property
properties
#
A.a
A[`a`]
A['a']
A["a"]

# Instance
a=new A()
a
A.prototype
A: ...

#
regExp=new RegExp()
regExp
RegExp.prototype
RegExp: ...





# Ex.
Response
ㄴConstructor
　ㄴResponse()
ㄴStatic methods
　ㄴResponse.error()
ㄴInstance properties
　ㄴresponse.body 
ㄴInstance methods
　ㄴresponse.arrayBuffer()
#
JSON
ㄴStatic properties
　ㄴJSON[Symbol.toStringTag]
ㄴStatic methods
　ㄴJSON.isRawJSON()




# 재정의vs.본래정의
재정의ㄱㄱ.
ㄴConstructor -> Instance
ㄴStatic -> Constructor
즉,
ㄴStatic -> Constructor -> Instance
ㄴ이런식으로
ㄴㄱㄱ.

아..
ㄴ아니다.
ㄴ그냥
ㄴ생성자
ㄴ여기서
ㄴinstance
ㄴ이쪽으로
ㄴ바로내려가는식으로ㄱㄱ.
ㄴ그게
ㄴ정렬도안깨지고
ㄴ순서보장
ㄴ딱좋음.
특히
ㄴ생성자.
ㄴ클래스명.
ㄴ완연동일.
ㄴ그리고
ㄴ()
ㄴ형식만을붙이기에.
ㄴㄱㄱ.
즉,
ㄴclass -> constrcutor -> instance
ㄴclass -> static
더하여
ㄴclass -> constrcutor             -> instance
ㄴclass                -> static



# constructor-instance

a.a()
new A().a()
ㄴ근데.
ㄴ쬐까.
ㄴ다르긴한다.
ㄴ연속성있기하나.
ㄴ뭔가.
ㄴ거시기함.
ㄴ애당초
ㄴ목적성
ㄴ사용방향성
ㄴ사용방법론.
ㄴ그런것들이
ㄴnew까지
ㄴ들어가고서
ㄴ그제서부터
ㄴ시작되기에.
ㄴ막
ㄴ딱붙이기에는
ㄴ비최적인듯.
그리고
ㄴstatic이
ㄴ나중에나왔다함.
ㄴconstructor
ㄴ이게
ㄴ제일먼저나오고.
그리고
ㄴ이개념들
ㄴOOP개념에서
ㄴ왔으니.
ㄴnew
ㄴ이형태로
ㄴ싹
ㄴ진행하는듯.
그렇기에
ㄴ당해위해
ㄴㄱㄱ.



